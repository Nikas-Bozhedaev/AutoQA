fun main() {
    /**
      * Решил не делать отдельный код для каждой задачи.
      * Поэтому написал подобие цельной программки, которая включает все необходимые задания.
    */
    println("Введите количество блокеров")
    var bug_blocker = readLine()?.toIntOrNull() ?: 0
    // Здесь к команде readLine добавил функцию toIntOrNull, которая конвертирует введенную строку в целое число.
    // При этом если преобразование не получится, то переменная примет значение null. Но в таком случае сработает оператор справа
    // И установит дефолтное значение - 0 
    println("Введите количество критов")
    var bug_critical = readLine()?.toIntOrNull() ?: 0

    println("Введите количество нормалов")
    var bug_normal = readLine()?.toIntOrNull() ?: 0

    println("Введите количество миноров")
    var bug_minor = readLine()?.toIntOrNull() ?: 0
    // В этой переменной использую операторы равенства. Условно результат ок, если нет блокеров и критов меньше, чем всех остальных багов
    val positive_result = bug_blocker == 0 && (bug_critical < bug_normal + bug_minor)
    // В следующей строке использовал подобие fстринге в python. Чтобы не выносить общее количество багов в отдельную переменную
    // Пересчитал их при выводе строки
    println("Всего багов: ${bug_blocker + bug_critical + bug_normal + bug_minor}")
    // Условных операторов еще в задании не было, но я давно не кодил и не придумал, как реализовать свою логику без них
    // Поэтому пусть будет :)
    // В ветвлении обработал 3 сценария. Конечно, можно было оставить 2 нижних, но состояния "Прогон не может быть завершен"
    // И "Сборка не может быть пошарена заказчику" немного разные
    if (bug_blocker > 0) {
        println("Прогон не может быть завершен")
    }
    else if (positive_result) {
        println("Сборка может быть пошарена заказчику")
    }
    else {
        println("Сборка не может быть пошарена заказчику")  
    }
}